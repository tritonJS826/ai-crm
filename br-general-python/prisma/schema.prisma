// Unified Chat + In-Chat Checkout MVP

generator client {
  provider             = "prisma-client-py"
  recursive_type_depth = 5
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// ENUMS
// ============================================

enum Role {
  ADMIN
  AGENT
}

enum Platform {
  WHATSAPP
  MESSENGER
  INSTAGRAM
}

enum ConversationStatus {
  OPEN
  CLOSED
}

enum OrderStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

// ============================================
// CORE MODELS
// ============================================

/// User model for authentication and authorization.
/// Roles: ADMIN (full access), AGENT (inbox access only).
model User {
  id              String   @id @default(cuid())
  email           String   @unique
  hashed_password String   @map("hashed_password")
  name            String
  role            Role     @default(AGENT)
  createdAt       DateTime @default(now()) @map("created_at")

  @@map("users")
}

/// Contact represents a customer from messaging platforms.
/// Each contact is unique per platform + platformUserId combination.
model Contact {
  id             String   @id @default(cuid())
  platform       Platform
  platformUserId String   @map("platform_user_id")
  phone          String? // E.164 format for WhatsApp
  name           String?
  optOut         Boolean  @default(false) @map("opt_out")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  conversations Conversation[]
  orders        Order[]

  @@unique([platform, platformUserId])
  @@index([platform])
  @@map("contacts")
}

/// Conversation groups messages with a contact.
/// Status: OPEN (active), CLOSED (archived).
model Conversation {
  id            String             @id @default(cuid())
  contactId     String             @map("contact_id")
  contact       Contact            @relation(fields: [contactId], references: [id], onDelete: Cascade)
  status        ConversationStatus @default(OPEN)
  lastMessageAt DateTime           @default(now()) @map("last_message_at")
  createdAt     DateTime           @default(now()) @map("created_at")
  updatedAt     DateTime           @updatedAt @map("updated_at")

  messages Message[]

  @@index([lastMessageAt(sort: Desc)])
  @@index([contactId])
  @@index([status])
  @@map("conversations")
}

/// Message stores individual chat messages.
/// fromUserId: NULL = from agent, NOT NULL = from contact.
model Message {
  id              String       @id @default(cuid())
  conversationId  String       @map("conversation_id")
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  fromUserId      String?      @map("from_user_id")
  platform        Platform
  text            String?
  mediaUrl        String?      @map("media_url")
  remoteMessageId String?      @map("remote_message_id")
  createdAt       DateTime     @default(now()) @map("created_at")

  @@index([conversationId, createdAt])
  @@map("messages")
}

/// Product catalog for in-chat checkout.
/// stripePriceId links to Stripe Price object.
model Product {
  id            String   @id @default(cuid())
  title         String
  priceCents    Int      @map("price_cents")
  currency      String   @default("USD")
  imageUrl      String?  @map("image_url")
  description   String?
  stripePriceId String   @map("stripe_price_id")
  isActive      Boolean  @default(true) @map("is_active")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  orders Order[]

  @@index([isActive])
  @@map("products")
}

/// Order tracks purchases made through chat.
/// conversationId allows sending confirmation back to chat.
model Order {
  id              String      @id @default(cuid())
  contactId       String      @map("contact_id")
  contact         Contact     @relation(fields: [contactId], references: [id], onDelete: Cascade)
  productId       String      @map("product_id")
  product         Product     @relation(fields: [productId], references: [id], onDelete: Cascade)
  conversationId  String?     @map("conversation_id")
  amountCents     Int         @map("amount_cents")
  currency        String
  stripeSessionId String      @unique @map("stripe_session_id")
  status          OrderStatus @default(PENDING)
  createdAt       DateTime    @default(now()) @map("created_at")
  updatedAt       DateTime    @updatedAt @map("updated_at")

  @@index([contactId])
  @@index([status])
  @@map("orders")
}

/// EmailLog for tracking sent emails.
/// Preserved from original codebase.
model EmailLog {
  id        String   @id @default(cuid())
  to        String
  subject   String
  template  String?
  body      String?
  status    String
  error     String?
  createdAt DateTime @default(now()) @map("created_at")

  @@map("email_logs")
}

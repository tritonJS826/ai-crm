/* tslint:disable */
/* eslint-disable */
{{>licenseInfo}}

import { apiClient } from "src/services/apiClient";

{{#imports.0}}
import type {
  {{#imports}}
  {{className}},
  {{/imports}}
} from '../models/index{{importFileExtension}}';
{{^withoutRuntimeChecks}}
import {
    {{#imports}}
    {{className}}FromJSON,
    {{className}}ToJSON,
    {{/imports}}
} from '../models/index{{importFileExtension}}';
{{/withoutRuntimeChecks}}
{{/imports.0}}

{{#operations}}
/**
 * {{#lambda.indented_star_1}}{{{unescapedDescription}}}{{/lambda.indented_star_1}}
 */
export class {{classname}} {

    {{#operation}}
    /**
     {{#notes}}
     * {{&notes}}
     {{/notes}}
     {{#summary}}
     * {{&summary}}
     {{/summary}}
     {{#isDeprecated}}
     * @deprecated
     {{/isDeprecated}}
     */
    async {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}}, {{/allParams}}initOverrides?: RequestInit): Promise<{{{returnType}}}{{#returnType}}{{#isResponseOptional}} | null | undefined {{/isResponseOptional}}{{/returnType}}{{^returnType}}void{{/returnType}}> { 
        {{#allParams}}
        {{#required}}
        if ({{paramName}} == null) {
            throw new Error(
                'Required parameter "{{paramName}}" was null or undefined when calling {{nickname}}().'
            );
        }

        {{/required}}
        {{/allParams}}
        const queryParameters: Record<string, string> = {};

        {{#queryParams}}
        {{#isArray}}
        if ({{paramName}} != null) {
            {{#isCollectionFormatMulti}}
            queryParameters['{{baseName}}'] = '{{paramName}}';
            {{/isCollectionFormatMulti}}
            {{^isCollectionFormatMulti}}
            queryParameters['{{baseName}}'] = {{#uniqueItems}}Array.from({{/uniqueItems}}{{paramName}}{{#uniqueItems}}){{/uniqueItems}}!.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]);
            {{/isCollectionFormatMulti}}
        }

        {{/isArray}}
        {{^isArray}}
        if ({{paramName}} != null) {
            {{#isExplode}}
            {{#isContainer}}
            for (let key of Object.keys({{paramName}})) {
                queryParameters[key] ={{paramName}}[key];
            }
            {{/isContainer}}
            {{^isContainer}}
{{>apisAssignQueryParam}}
            {{/isContainer}}
            {{/isExplode}}
            {{^isExplode}}
{{>apisAssignQueryParam}}
            {{/isExplode}}
        }
        {{/isArray}}
        {{/queryParams}}
        
        let urlPath = `{{{path}}}`;
        {{#pathParams}}
        {{#isDateTimeType}}
        if (requestParameters['{{paramName}}'] instanceof Date) {
            urlPath = urlPath.replace(`{${"{{baseName}}"}}`, encodeURIComponent({{paramName}}.toISOString()));
        } else {
            urlPath = urlPath.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}})));
        }
        {{/isDateTimeType}}
        {{^isDateTimeType}}
        {{#isDateType}}
        if (requestParameters['{{paramName}}'] instanceof Date) {
            urlPath = urlPath.replace(`{${"{{baseName}}"}}`, encodeURIComponent({{paramName}}.toISOString().substring(0,10)));
        } else {
            urlPath = urlPath.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}})));
        }
        {{/isDateType}}
        {{^isDateType}}
        urlPath = urlPath.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}})));
        {{/isDateType}}
        {{/isDateTimeType}}
        {{/pathParams}}

        return await apiClient.request(
          "{{httpMethod}}",
          urlPath,
          {{#hasBodyParam}}
          {{#bodyParam}}
          {{#isContainer}}
          {{^withoutRuntimeChecks}}
          {{paramName}}{{#isArray}}{{#items}}{{^isPrimitiveType}}!.map({{datatype}}ToJSON){{/isPrimitiveType}}{{/items}}{{/isArray}},
          {{/withoutRuntimeChecks}}
          {{#withoutRuntimeChecks}}
          {{paramName}},
          {{/withoutRuntimeChecks}}
          {{/isContainer}}
          {{^isContainer}}
          {{^isPrimitiveType}}
          {{^withoutRuntimeChecks}}
          {{dataType}}ToJSON({{paramName}}),
          {{/withoutRuntimeChecks}}
          {{#withoutRuntimeChecks}}
          {{paramName}},
          {{/withoutRuntimeChecks}}
          {{/isPrimitiveType}}
          {{#isPrimitiveType}}
          {{paramName}} as any,
          {{/isPrimitiveType}}
          {{/isContainer}}
          {{/bodyParam}}
          {{/hasBodyParam}}
          initOverrides);

    }

    {{/operation}}
}
{{/operations}}
{{#hasEnums}}

{{#operations}}
{{#operation}}
{{#allParams}}
{{#isEnum}}
{{#stringEnums}}
/**
  * @export
  * @enum {string}
  */
export enum {{operationIdCamelCase}}{{enumName}} {
{{#allowableValues}}
    {{#enumVars}}
    {{{name}}} = {{{value}}}{{^-last}},{{/-last}}
    {{/enumVars}}
{{/allowableValues}}
}
{{/stringEnums}}
{{^stringEnums}}
/**
 * @export
 */
export const {{operationIdCamelCase}}{{enumName}} = {
{{#allowableValues}}
    {{#enumVars}}
    {{{name}}}: {{{value}}}{{^-last}},{{/-last}}
    {{/enumVars}}
{{/allowableValues}}
} as const;
export type {{operationIdCamelCase}}{{enumName}} = typeof {{operationIdCamelCase}}{{enumName}}[keyof typeof {{operationIdCamelCase}}{{enumName}}];
{{/stringEnums}}
{{/isEnum}}
{{/allParams}}
{{/operation}}
{{/operations}}
{{/hasEnums}}

export const {{classVarName}}Api = new {{classname}}();